#include "veins/modules/application/traci/TraCIDemo11p.h"

#include "veins/modules/application/traci/TraCIDemo11pMessage_m.h"
#include <iostream> // AÃ±ade al inicio del archivo


using namespace veins;

protected:
    bool hasCrashed;
    simtime_t collisionTime;
    static const simtime_t COLLISION_RESET_TIME = 30; // segundos

Define_Module(veins::TraCIDemo11p);

void TraCIDemo11p::initialize(int stage)
{
    std::cout << "ðŸš€ Iniciando mÃ³dulo TraCIDemo11p: " << getExternalId() << std::endl;

    DemoBaseApplLayer::initialize(stage);
    /*if (stage == 0) {
        sentMessage = false;
        hasCrashed = false;  // Inicializar estado
        lastDroveAt = simTime();
        currentSubscribedServiceId = -1;
    }*/
    if (stage == 0) {
        sentMessage = false;
        hasCrashed = false;
        lastDroveAt = simTime();
        currentSubscribedServiceId = -1;

        mobility->subscribe(this);  // â† Â¡Esta lÃ­nea es crucial!
    }
}

void TraCIDemo11p::onWSA(DemoServiceAdvertisment* wsa)
{
    if (currentSubscribedServiceId == -1) {
        mac->changeServiceChannel(static_cast<Channel>(wsa->getTargetChannel()));
        currentSubscribedServiceId = wsa->getPsid();
        if (currentOfferedServiceId != wsa->getPsid()) {
            stopService();
            startService(static_cast<Channel>(wsa->getTargetChannel()), wsa->getPsid(), "Mirrored Traffic Service");
        }
    }
}

void TraCIDemo11p::onWSM(BaseFrame1609_4* frame)
{
    TraCIDemo11pMessage* wsm = check_and_cast<TraCIDemo11pMessage*>(frame);

    /*
    if (mobility->getRoadId()[0] != ':') traciVehicle-> Route(wsm->getDemoData(), 9999);
    if (!sentMessage) {
        sentMessage = true;
        wsm->setSenderAddress(myId);
        wsm->setSerial(3);
        scheduleAt(simTime() + 2 + uniform(0.01, 0.2), wsm->dup());
    }*/
}

void TraCIDemo11p::handleSelfMsg(cMessage* msg)
{
    if (TraCIDemo11pMessage* wsm = dynamic_cast<TraCIDemo11pMessage*>(msg)) {

        sendDown(wsm->dup());
        wsm->setSerial(wsm->getSerial() + 1);
        if (wsm->getSerial() >= 3) {
            // stop service advertisements
            stopService();
            delete (wsm);
        }
        else {
            scheduleAt(simTime() + 1, wsm);
        }
    }
    else {
        DemoBaseApplLayer::handleSelfMsg(msg);
    }
}

void TraCIDemo11p::handlePositionUpdate(cObject* obj)
{
    /*DemoBaseApplLayer::handlePositionUpdate(obj);

    // stopped for for at least 10s?
    if (mobility->getSpeed() < 1) {
        if (simTime() - lastDroveAt >= 10 && sentMessage == false) {
            findHost()->getDisplayString().setTagArg("i", 1, "red");
            sentMessage = true;

            TraCIDemo11pMessage* wsm = new TraCIDemo11pMessage();
            populateWSM(wsm);
            wsm->setDemoData(mobility->getRoadId().c_str());

            // host is standing still due to crash
            if (dataOnSch) {
                startService(Channel::sch2, 42, "Traffic Information Service");
                // started service and server advertising, schedule message to self to send later
                scheduleAt(computeAsynchronousSendingTime(1, ChannelType::service), wsm);
            }
            else {
                // send right away on CCH, because channel switching is disabled
                sendDown(wsm);
            }
        }
    }
    else {
        lastDroveAt = simTime();
    }*/

    DemoBaseApplLayer::handlePositionUpdate(obj);

    // MÃ©todo mejorado para detectar colisiones
        bool currentCollision = false;
        std::string collisionPartners = "";

        try {
            // Intenta obtener IDs de vehÃ­culos colisionados (mÃ©todo alternativo)
            auto nearbyVehicles = traciVehicle->getNeighbors();
            double minDistance = traciVehicle->getLength() * 0.8; // Umbral de colisiÃ³n

            for (auto& vehicle : nearbyVehicles) {
                double distance = traciVehicle->getDistanceTo(vehicle);
                if (distance < minDistance) {
                    currentCollision = true;
                    collisionPartners += vehicle + " ";
                }
            }
        } catch (const std::exception& e) {
            std::cerr << "ERROR al verificar colisiones: " << e.what() << std::endl;
        }

        std::cout << "Debug: Detectando colisiones para " << getExternalId() << std::endl;
        std::cout << "Vecinos detectados: " << nearbyVehicles.size() << std::endl;

        if (hasCrashed) {
            //findHost()->getDisplayString().setTagArg("i", 1, "blue");
            traciVehicle->setColor(TraCIColor(0, 0, 255));  // Azul
            getParentModule()->getDisplayString().setTagArg("t", 0, "COLISIÃ“N");
        }

        if (currentCollision && !hasCrashed) {
            hasCrashed = true;
            collisionTime = simTime();

            // Mensaje detallado por cout
            std::cout << "\n========================================"
                      << "\n|   COLISIÃ“N DETECTADA - CONSOLA       |"
                      << "\n========================================"
                      << "\n| VehÃ­culo: " << getExternalId()
                      << "\n| Tiempo: " << simTime().str() << "s"
                      << "\n| PosiciÃ³n: X=" << mobility->getPositionAt(simTime()).x
                      << " Y=" << mobility->getPositionAt(simTime()).y
                      << "\n| VehÃ­culos involucrados: " << (collisionPartners.empty() ? "OBJETO" : collisionPartners)
                      << "\n========================================\n" << std::endl;

            // Cambios visuales
            traciVehicle->setColor(TraCIColor(255, 0, 0, 255));
            //findHost()->getDisplayString().setTagArg("i", 1, "blue");
            traciVehicle->setColor(TraCIColor(0, 0, 255));  // Azul
            findHost()->getDisplayString().setTagArg("t", 0, "âœ– COLISIÃ“N");
            EV << "ðŸš¨ VehÃ­culo " << traciVehicle->getId() << " ha colisionado en " << simTime() << "s\n";

            std::cout << "ðŸš—âŒ ColisiÃ³n detectada para vehÃ­culo " << traciVehicle->getId() << " en tiempo " << simTime() << std::endl;


            // Detener vehÃ­culo
            traciVehicle->setSpeed(0);
            traciVehicle->setSpeedMode(0x00);
        }
        std::cout << "Test: handlePositionUpdate ejecutado en tiempo: " << simTime().str() << std::endl;
       // Resto de tu lÃ³gica existente...
       if (mobility->getSpeed() < 1) {
           if (simTime() - lastDroveAt >= 10 && sentMessage == false) {

               //findHost()->getDisplayString().setTagArg("i", 1, "blue");
               traciVehicle->setColor(TraCIColor(0, 0, 255));  // Azul

                           sentMessage = true;

                           TraCIDemo11pMessage* wsm = new TraCIDemo11pMessage();
                           populateWSM(wsm);
                           wsm->setDemoData(mobility->getRoadId().c_str());

                           // host is standing still due to crash
                           if (dataOnSch) {
                               startService(Channel::sch2, 42, "Traffic Information Service");
                               // started service and server advertising, schedule message to self to send later
                               scheduleAt(computeAsynchronousSendingTime(1, ChannelType::service), wsm);
                           }
                           else {
                               // send right away on CCH, because channel switching is disabled
                               sendDown(wsm);
                           }
           }
       }
       else {
           lastDroveAt = simTime();
       }
}
